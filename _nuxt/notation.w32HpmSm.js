import{_ as h,h as i,o as u,c as p,i as _,v as g,d as t,g as e,t as s,e as r,w as m,a as f,f as v}from"./entry.JQLtebXm.js";import{i as w,p as x}from"./notationValidator.RugS-jTn.js";const b={components:{ErrorForm:i},data(){return{notation:""}},head(){return{title:"Validate a Chess Move"}},computed:{currentIsValid(){return w({notation:this.notation})},currentParse(){return x({notation:this.notation})}}},k={class:"prose prose-red container mx-auto my-12 text-justify"},N=f('<h1>Validate a Chess Move</h1><p> This checks for valid algebraic notation. I mostly adhered to <a href="https://handbook.fide.com/chapter/E012018">FIDE&#39;s rules</a>, but to handle a few more common notations I expanded it a bit. Both <strong>0-0-0</strong> and <strong>0-0</strong> are validated with zeros or capital Os. Promotions are acceptable written as both <strong>d8Q</strong> and <strong>d8=Q</strong>. I also allow <strong>P</strong> to indicate a pawn, even though that&#39;s not technically correct (e.g. <strong>e4</strong> is preferred over <strong>Pe4</strong>). Note that this is case sensitive and space sensitive (e.g. <strong>ke4+(=)</strong> is invalid but <strong>Ke4+ (=)</strong> is valid). </p><h3>Validate Notation:</h3>',3),V=t("hr",null,null,-1),y=t("a",{href:"https://github.com/Chalks/jdw.me/blob/master/src/assets/js/notationValidator.js"},"here",-1),I=t("p",null,"Some fun questions to answer:",-1),j=t("ul",null,[t("li",null,"Which moves can a king make that will never result in a check?"),t("li",null,[e("When is a draw offer (e.g. "),t("strong",null,"d4 (=)"),e(") not valid?")]),t("li",null,"Where can a pawn never move from?")],-1),E=t("hr",null,null,-1),P=t("p",null,"Did you find an error? Let me know below please!",-1);function B(C,o,D,F,n,a){const l=v,c=i;return u(),p("div",k,[N,_(t("input",{ref:"notationField","onUpdate:modelValue":o[0]||(o[0]=d=>n.notation=d),type:"text",placeholder:"Notation (e.g. Nxd3)"},null,512),[[g,n.notation]]),t("p",null,[e("Is valid: "),t("strong",null,s(a.currentIsValid),1)]),t("pre",null,'"parsed": '+s(a.currentParse),1),V,t("p",null,[e(" If you need help finding a notation to validate, you can check out all the possible legal ones "),r(l,{to:"/fun/all-notations"},{default:m(()=>[e("here")]),_:1}),e(". If you want to see the code used to validate the notation, you can see that "),y,e(". ")]),I,j,E,P,r(c,{subject:"notation","message-placeholder":"Notation with an error"})])}const T=h(b,[["render",B]]);export{T as default};
